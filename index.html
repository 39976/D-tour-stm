// =============== 3. TROUVER LE NOM + TOUS LES SEGMENTS DE LA RUE ===============
async function getStreetSegments(lat, lng) {

  // 1) D'abord trouver LE tronçon cliqué (nom de la rue)
  const query1 = `
    [out:json];
    way(around:20, ${lat}, ${lng})["highway"]["name"];
    out tags;
  `;
  const res1 = await fetch("https://overpass-api.de/api/interpreter", {
    method: "POST",
    headers: { "Content-Type": "text/plain" },
    body: query1
  });
  const json1 = await res1.json();

  if (!json1.elements || json1.elements.length === 0) {
    return { name: "Rue inconnue", segments: [] };
  }

  const streetName = json1.elements[0].tags.name;

  // 2) Maintenant récupérer TOUS les segments qui portent ce nom
  const query2 = `
    [out:json];
    way(around:3000, ${lat}, ${lng})["name"="${streetName}"];
    out geom;
  `;
  const res2 = await fetch("https://overpass-api.de/api/interpreter", {
    method: "POST",
    headers: { "Content-Type": "text/plain" },
    body: query2
  });
  const json2 = await res2.json();

  const segments = json2.elements.map(way =>
    way.geometry.map(pt => [pt.lat, pt.lon])
  );

  return { name: streetName, segments };
}

// =============== 4. AFFICHER LES TRACÉS SUR TOUS LES SEGMENTS ===============
function drawLinesForStreet(streetName, segments) {
  clearLines();

  const filt = document.getElementById("ligne").value.trim();
  const lignes = streetLines[streetName] || [];
  const lignesFiltrees = filt ? lignes.filter(l => l === filt) : lignes;

  if (lignesFiltrees.length === 0) return lignes;

  segments.forEach(segment => {
    lignesFiltrees.forEach(num => {
      const col = lineColors[num] || "black";
      const poly = L.polyline(segment, {
        color: col,
        weight: 6,
        opacity: 0.9
      }).addTo(map);
      displayedLines.push(poly);
    });
  });

  return lignesFiltrees;
}
