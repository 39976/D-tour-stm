<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>STM ‚Äì Lignes, Arr√™ts & Temps r√©el</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

<style>
    html, body{
        margin:0;
        padding:0;
        height:100%;
        font-family:Arial, sans-serif;
    }

    #map{
        width:100%;
        height:100%;
    }

    /* Barre de recherche */
    #searchBar{
        position:fixed;
        top:10px;
        left:50%;
        transform:translateX(-50%);
        width:90%;
        max-width:600px;
        padding:8px;
        display:flex;
        gap:6px;
        background:#005AAF;
        border-radius:999px;
        box-shadow:0 4px 15px rgba(0,0,0,.35);
        z-index:1000;
    }
    #searchInput{
        flex:1;
        border:none;
        border-radius:999px;
        padding:9px 14px;
        font-size:15px;
    }
    #searchInput:focus{outline:none;}
    #searchBtn{
        background:#FFD100;
        border:none;
        border-radius:999px;
        padding:9px 14px;
        font-size:15px;
        font-weight:bold;
        cursor:pointer;
        white-space:nowrap;
    }

    /* Bo√Æte mobile */
    #mobileInfoBox{
        position:fixed;
        bottom:15px;
        left:50%;
        transform:translateX(-50%);
        width:94%;
        max-width:700px;
        background:white;
        border-radius:14px;
        max-height:55%;
        overflow-y:auto;
        padding:16px;
        box-shadow:0 5px 25px rgba(0,0,0,.40);
        z-index:999;
        display:none;
    }
    #closeMobileBox{
        margin-top:14px;
        padding:10px;
        border-radius:8px;
        background:#005AAF;
        color:white;
        text-align:center;
        font-weight:bold;
        cursor:pointer;
    }

    h2{margin:0 0 6px 0;font-size:20px;}
    h3{margin:10px 0 6px 0;font-size:16px;}
    p{margin:2px 0;}
    ol{
        padding-left:22px;
        line-height:1.55;
        margin:6px 0 0 0;
    }

    .line-group{margin-bottom:10px;}
    .line-group-title{font-weight:bold;margin-bottom:4px;}

    .btn-line, .btn-secondary, .btn-realtime{
        width:100%;
        margin-top:4px;
        padding:8px 10px;
        border-radius:6px;
        border:1px solid #ddd;
        font-size:14px;
        cursor:pointer;
        text-align:left;
        background:#f5f5f5;
    }
    .btn-line:hover{background:#e3efff;}
    .btn-secondary{
        background:#f0f0f0;
        text-align:center;
    }
    .btn-realtime{
        background:#ffecc0;
        text-align:center;
    }

    .tag-direction{
        display:inline-block;
        margin-left:4px;
        padding:2px 6px;
        border-radius:999px;
        font-size:11px;
        background:#eef3ff;
    }
</style>
</head>
<body>

<div id="searchBar">
    <input id="searchInput" type="text" placeholder="Ligne (ex: 141) ou rue ex: Sherbrooke">
    <button id="searchBtn">Rechercher</button>
</div>

<div id="mobileInfoBox">
    <div id="mobileContent"></div>
    <div id="closeMobileBox">Fermer</div>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
// =====================================================
// 0) Carte & UI de base
// =====================================================
const map = L.map("map").setView([45.55, -73.65], 13);
L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 22
}).addTo(map);

const stmIcon = L.icon({
    iconUrl: "https://i.imgur.com/IIZOOia.png",
    iconSize: [40, 40],
    iconAnchor: [20, 40]
});

const mobileBox   = document.getElementById("mobileInfoBox");
const mobileContent = document.getElementById("mobileContent");
document.getElementById("closeMobileBox").onclick = () => mobileBox.style.display = "none";
function show(html){
    mobileContent.innerHTML = html;
    mobileBox.style.display = "block";
}

// =====================================================
// 1) Globals pour les couches
// =====================================================
let allStopMarkers = [];
let routeLayer     = null;
let routeStopsLayer = null;
let realtimeLayer  = null;
let realtimeTimer  = null;

// =====================================================
// 2) Fonctions utilitaires
// =====================================================
function setAllStopsVisible(visible){
    allStopMarkers.forEach(m => {
        if (visible){
            if (!map.hasLayer(m)) m.addTo(map);
        }else{
            if (map.hasLayer(m)) map.removeLayer(m);
        }
    });
}

function clearRouteLayers(){
    if (routeLayer && map.hasLayer(routeLayer)) map.removeLayer(routeLayer);
    routeLayer = null;
    if (routeStopsLayer && map.hasLayer(routeStopsLayer)) map.removeLayer(routeStopsLayer);
    routeStopsLayer = null;
}

function stopRealtime(){
    if (realtimeTimer){
        clearInterval(realtimeTimer);
        realtimeTimer = null;
    }
    if (realtimeLayer && map.hasLayer(realtimeLayer)){
        map.removeLayer(realtimeLayer);
        realtimeLayer = null;
    }
}

// Couleur pseudo-d√©terministe par num√©ro de ligne
function colorForRef(ref){
    const palette = ["#0F9D58","#1A73E8","#DB4437","#FF9900","#9C27B0","#00897B","#795548","#F4511E","#43A047"];
    let n = parseInt(ref,10);
    if (Number.isNaN(n)){
        n = ref.split("").reduce((s,c)=>s + c.charCodeAt(0),0);
    }
    return palette[n % palette.length];
}

function directionLabel(tags){
    const from = tags.from || "";
    const to   = tags.to   || "";
    const dir  = tags.direction || "";
    const name = tags.name || "";
    if (from && to) return `${from} ‚Üí ${to}`;
    if (dir) return dir;
    if (name) return name;
    return "Direction inconnue";
}

function escapeForOnclick(str){
    return String(str).replace(/'/g,"&#39;");
}

// =====================================================
// 3) Charger tous les arr√™ts STM (une fois)
// =====================================================
async function loadAllStops(){
    const query = `
    [out:json][timeout:40];
    area["name"="Montr√©al"]->.m;
    node["highway"="bus_stop"]["network"="STM"](area.m);
    out body;
    `;
    try{
        const res = await fetch("https://overpass-api.de/api/interpreter",{
            method:"POST",
            headers:{ "Content-Type":"application/x-www-form-urlencoded" },
            body: "data=" + encodeURIComponent(query)
        });
        const data = await res.json();

        data.elements.forEach(stop => {
            const marker = L.marker([stop.lat, stop.lon], {icon: stmIcon}).addTo(map);
            marker.on("click", () => openStop(stop));
            allStopMarkers.push(marker);
        });
    }catch(e){
        console.error("Erreur Overpass (arr√™ts):", e);
    }
}
loadAllStops();

// =====================================================
// 4) Clic sur un arr√™t ‚Üí lignes + directions
// =====================================================
async function openStop(stop){
    stopRealtime();
    clearRouteLayers();
    setAllStopsVisible(true);

    const q = `
    [out:json][timeout:40];
    rel["route"="bus"]["network"="STM"](around:40, ${stop.lat}, ${stop.lon});
    out body;
    `;
    try{
        const r = await fetch("https://overpass-api.de/api/interpreter",{
            method:"POST",
            headers:{ "Content-Type":"application/x-www-form-urlencoded"},
            body: "data=" + encodeURIComponent(q)
        });
        const d = await r.json();
        const rels = d.elements.filter(e => e.type === "relation");

        const byRef = {};
        rels.forEach(rel => {
            const ref = rel.tags.ref || rel.tags["ref:STM"] || "?";
            if (!ref) return;
            if (!byRef[ref]) byRef[ref] = [];
            byRef[ref].push(rel);
        });

        const groupsHtml = Object.keys(byRef).sort().map(ref => {
            const items = byRef[ref].map(rel => {
                const label = directionLabel(rel.tags);
                const labelEsc = escapeForOnclick(label);
                return `
                    <button class="btn-line"
                        onclick="loadRoute('${ref}', ${rel.id}, '${labelEsc}')">
                        üöç Ligne ${ref}
                        <span class="tag-direction">${label}</span>
                    </button>
                `;
            }).join("");
            return `
                <div class="line-group">
                    <div class="line-group-title">Ligne ${ref}</div>
                    ${items}
                </div>
            `;
        }).join("") || "<p>Aucune ligne STM trouv√©e pour cet arr√™t.</p>";

        show(`
            <h2>${stop.tags.name || "Arr√™t STM"}</h2>
            <p><b>ID:</b> ${stop.id}</p>
            <h3>Lignes desservies :</h3>
            ${groupsHtml}
        `);
        map.panTo([stop.lat, stop.lon]);
    }catch(e){
        console.error("Erreur Overpass (openStop):", e);
    }
}

// =====================================================
// 5) Recherche d‚Äôune ligne (num√©ro) ‚Üí liste directions
// =====================================================
async function searchLineByRef(ref){
    stopRealtime();
    clearRouteLayers();
    setAllStopsVisible(true);

    const q = `
    [out:json][timeout:60];
    (
        relation["route"="bus"]["network"="STM"]["ref"="${ref}"];
        relation["route"="bus"]["network"="STM"]["ref:STM"="${ref}"];
        relation["route"="bus"]["network"="STM"]["name"~"(^| )${ref}( |$)"];
    );
    out body;
    `;
    try{
        const r = await fetch("https://overpass-api.de/api/interpreter",{
            method:"POST",
            headers:{ "Content-Type":"application/x-www-form-urlencoded"},
            body: "data=" + encodeURIComponent(q)
        });
        const d = await r.json();
        const rels = d.elements.filter(e => e.type === "relation");
        if (!rels.length){
            alert("Ligne introuvable dans Overpass / OSM");
            return;
        }

        const byRef = {};
        rels.forEach(rel => {
            const rRef = rel.tags.ref || rel.tags["ref:STM"] || ref;
            if (!byRef[rRef]) byRef[rRef] = [];
            byRef[rRef].push(rel);
        });

        const groupsHtml = Object.keys(byRef).sort().map(rr => {
            const items = byRef[rr].map(rel => {
                const label = directionLabel(rel.tags);
                const labelEsc = escapeForOnclick(label);
                return `
                    <button class="btn-line"
                        onclick="loadRoute('${rr}', ${rel.id}, '${labelEsc}')">
                        üöç Ligne ${rr}
                        <span class="tag-direction">${label}</span>
                    </button>
                `;
            }).join("");
            return `
                <div class="line-group">
                    <div class="line-group-title">Ligne ${rr}</div>
                    ${items}
                </div>
            `;
        }).join("");

        show(`
            <h2>Choisir une direction ‚Äì ligne ${ref}</h2>
            ${groupsHtml}
        `);
    }catch(e){
        console.error("Erreur Overpass (searchLineByRef):", e);
    }
}

// =====================================================
// 6) Charger une relation pr√©cise (ligne + direction)
//     üÖ∞ arr√™ts de la ligne uniquement
//     üÖ± couleur diff√©rente
// =====================================================
async function loadRoute(ref, relId, label){
    stopRealtime();
    clearRouteLayers();
    setAllStopsVisible(false);  // üÖ∞ cacher tous les autres arr√™ts

    const q = `
    [out:json][timeout:60];
    relation(${relId});
    (._;>;);
    out body;
    `;
    try{
        const r = await fetch("https://overpass-api.de/api/interpreter",{
            method:"POST",
            headers:{ "Content-Type":"application/x-www-form-urlencoded"},
            body: "data=" + encodeURIComponent(q)
        });
        const d = await r.json();

        const ways  = d.elements.filter(e => e.type === "way");
        const nodes = d.elements.filter(e => e.type === "node");
        const rel   = d.elements.find(e => e.type === "relation");

        if (!rel){
            alert("Relation introuvable pour cette direction.");
            return;
        }

        routeLayer = L.layerGroup().addTo(map);

        // tracer itin√©raire
        const col = colorForRef(ref);  // üÖ± couleur par ligne
        ways.forEach(w => {
            if (!w.geometry) return;
            L.polyline(w.geometry.map(p => [p.lat, p.lon]), {
                color: col,
                weight: 5
            }).addTo(routeLayer);
        });

        // arr√™ts dans l‚Äôordre
        const nodeMap = new Map(nodes.map(n => [n.id, n]));
        const stopsNodes = [];
        rel.members.forEach(m => {
            if (m.type === "node"){
                const n = nodeMap.get(m.ref);
                if (n && n.tags && n.tags.highway === "bus_stop"){
                    stopsNodes.push(n);
                }
            }
        });

        // couche des arr√™ts de la ligne uniquement üÖ∞
        routeStopsLayer = L.layerGroup().addTo(map);
        stopsNodes.forEach(n => {
            const mk = L.marker([n.lat, n.lon], {icon: stmIcon}).addTo(routeStopsLayer);
            mk.bindPopup(n.tags.name || "Arr√™t STM");
        });

        if (stopsNodes.length){
            map.fitBounds(L.latLngBounds(stopsNodes.map(n => [n.lat, n.lon])), {padding:[30,30]});
        }

        const stopsHtml = stopsNodes.length
            ? `<ol>${stopsNodes.map(n => `<li>${n.tags.name || "Arr√™t"}</li>`).join("")}</ol>`
            : "<p>Aucun arr√™t trouv√© pour cette direction.</p>";

        show(`
            <h2>üöç Ligne ${ref}</h2>
            <p>${label || ""}</p>
            <button class="btn-realtime" onclick="toggleRealtime('${ref}')">
                ‚è± Temps r√©el (b√™ta) ‚Äì ligne ${ref}
            </button>
            <button class="btn-secondary" onclick="showAllStops()">
                Afficher tous les arr√™ts STM
            </button>
            <h3>Arr√™ts dans l‚Äôordre de ce parcours :</h3>
            ${stopsHtml}
        `);
    }catch(e){
        console.error("Erreur Overpass (loadRoute):", e);
    }
}

// remettre tous les arr√™ts g√©n√©raux
function showAllStops(){
    stopRealtime();
    clearRouteLayers();
    if (routeStopsLayer && map.hasLayer(routeStopsLayer)){
        map.removeLayer(routeStopsLayer);
        routeStopsLayer = null;
    }
    setAllStopsVisible(true);
}

// =====================================================
// 7) Temps r√©el (üÖ≥ ‚Äì squelette √† brancher sur ton backend)
// =====================================================
function toggleRealtime(ref){
    // si d√©j√† actif ‚Üí stopper
    if (realtimeTimer){
        stopRealtime();
        alert("Temps r√©el d√©sactiv√©.");
        return;
    }
    alert("Temps r√©el activ√© (b√™ta). Assure-toi d'avoir configur√© YOUR_BACKEND_URL dans le code.");

    // chargement imm√©diat + toutes les 15 s
    loadRealtime(ref);
    realtimeTimer = setInterval(() => loadRealtime(ref), 15000);
}

async function loadRealtime(ref){
    if (realtimeLayer && map.hasLayer(realtimeLayer)){
        map.removeLayer(realtimeLayer);
    }
    realtimeLayer = L.layerGroup().addTo(map);

    try{
        // ‚ö†Ô∏è √Ä adapter : ton backend doit retourner un JSON de type :
        // { "vehicles": [ { "lat": 45.5, "lon": -73.6, "id": "bus123", "bearing": 90 } ] }
        const url = `https://YOUR_BACKEND_URL/stm/vehicles?line=${encodeURIComponent(ref)}`;
        const res = await fetch(url);
        const data = await res.json();

        if (!data.vehicles || !Array.isArray(data.vehicles)){
            console.warn("Format temps r√©el inattendu :", data);
            return;
        }

        data.vehicles.forEach(v => {
            const m = L.circleMarker([v.lat, v.lon], {
                radius: 6,
                color: "#000000",
                fillColor: "#FFD100",
                fillOpacity: 1
            }).addTo(realtimeLayer);
            const txt = `Bus ${v.id || ""} ‚Äì ligne ${ref}`;
            m.bindPopup(txt);
        });
    }catch(e){
        console.error("Erreur temps r√©el (loadRealtime):", e);
    }
}

// =====================================================
// 8) Recherche globale
// =====================================================
const searchInput = document.getElementById("searchInput");
const searchBtn   = document.getElementById("searchBtn");

searchBtn.onclick = () => handleSearch();
searchInput.addEventListener("keydown", e => {
    if (e.key === "Enter") handleSearch();
});

async function handleSearch(){
    const q = searchInput.value.trim();
    if (!q) return;

    // num√©ro de ligne ‚Üí chercher directions
    if (/^\d+$/.test(q)){
        await searchLineByRef(q);
        return;
    }

    // sinon ‚Üí g√©ocodage (adresse / rue)
    try{
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q+" Montr√©al")}`;
        const r = await fetch(url);
        const d = await r.json();
        if (!d.length){
            alert("Aucun r√©sultat pour cette recherche.");
            return;
        }
        const lat = parseFloat(d[0].lat);
        const lon = parseFloat(d[0].lon);
        map.setView([lat, lon], 16);
    }catch(e){
        console.error("Erreur recherche Nominatim:", e);
    }
}
</script>
</body>
</html>
