// Initialisation Leaflet
const map = L.map('map').setView([45.50,-73.56], 12);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

let polyline, stopMarkers = [], animMarker; 


/**************** 1) Charger les routes ****************/
async function loadRoutes(){
  const txt = await fetch("gtfs/routes.txt").then(r=>r.text());
  const routes = Papa.parse(txt,{header:true}).data;

  const select = document.getElementById("routeSelector");
  select.innerHTML = "<option value=''>-- Choisir une ligne --</option>";

  routes.forEach(r=>{
    if(r.route_id && r.route_short_name){
      select.innerHTML += `<option value="${r.route_id}">${r.route_short_name} â€” ${r.route_long_name}</option>`;
    }
  });
}
loadRoutes();


/************** 2) Lorsqu'une ligne est choisie **************/
document.getElementById("routeSelector").addEventListener("change", async e => {

  clearMap();

  const routeId = e.target.value;
  if(!routeId) return;

  // RÃ©cupÃ¨re tous les trips de la ligne
  const trips = await loadGTFS("gtfs/trips.txt");
  const tripsOfRoute = trips.filter(t => t.route_id===routeId);

  // Si 2 directions â†’ affichage des 2 couleurs
  const dirs = [...new Set(tripsOfRoute.map(t=>t.direction_id))];

  for(let i=0;i<dirs.length;i++){
    const trip = tripsOfRoute.find(t=>t.direction_id===dirs[i]);
    if(trip) await drawTrip(trip, i);
  }
});


/*************** ðŸ”¥ Fonction qui trace un TRIP ****************/
async function drawTrip(trip,index){

  // 1) charger shapes
  const shapes = await loadGTFS("gtfs/shapes.txt");
  const pts = shapes.filter(s=>s.shape_id===trip.shape_id)
    .sort((a,b)=>a.shape_pt_sequence-b.shape_pt_sequence)
    .map(p=>[+p.shape_pt_lat,+p.shape_pt_lon]);

  // couleurs pour aller/retour
  const colors=["#ff4444","#1e90ff","#ffb300","#00d67f"];

  polyline = L.polyline(pts,{color:colors[index],weight:5}).addTo(map);
  map.fitBounds(polyline.getBounds());

  // 2) Afficher les stops du trip ðŸ‘‡
  await drawStops(trip.trip_id, colors[index]);

  // 3) PrÃ©parer lâ€™animation
  prepareAnimation(pts, colors[index]);
}


/*********************** Stops + popups ***********************/
async function drawStops(tripId,color){

  const stopTimes=await loadGTFS("gtfs/stop_times.txt");
  const stops=await loadGTFS("gtfs/stops.txt");

  const ordered = stopTimes.filter(s=>s.trip_id===tripId)
      .sort((a,b)=>a.stop_sequence-b.stop_sequence);

  ordered.forEach(s=>{
    const st=stops.find(x=>x.stop_id===s.stop_id);
    if(!st) return;

    const m=L.circleMarker([+st.stop_lat,+st.stop_lon],{
      radius:5,color:"#000",fillColor:color,fillOpacity:1
    }).addTo(map);

    m.bindPopup(`<b>${st.stop_name}</b><br>Stop ID: ${s.stop_id}`);
    stopMarkers.push(m);
  });
}


/******************** Animation du trajet ðŸšŒ ********************/
let path= [], index=0, timer=null;

function prepareAnimation(points,color){
  path=points; index=0;

  if(animMarker) map.removeLayer(animMarker);
  animMarker=L.circleMarker(points[0],{radius:9,fillColor:color,fillOpacity:1}).addTo(map);
}

document.getElementById("animateBtn").onclick=()=>{
  if(timer) return; // Ã©vite double start
  timer=setInterval(()=>{
    if(index>=path.length) return clearInterval(timer);
    animMarker.setLatLng(path[index]);
    index++;
  },40); // vitesse
};


/**************** Utils ****************/
function clearMap(){
  if(polyline) map.removeLayer(polyline);
  stopMarkers.forEach(m=>map.removeLayer(m));
  stopMarkers=[];
  if(animMarker) map.removeLayer(animMarker);
  if(timer) clearInterval(timer);
}

async function loadGTFS(file){
  return Papa.parse(await (await fetch(file)).text(),{header:true}).data;
}
