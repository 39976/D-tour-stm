<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DÃ©tours STM â€“ Rue + vraies lignes STM</title>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #map {
      height: 100%;
      width: 100%;
    }

    #panel {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      background: white;
      padding: 10px;
      border-radius: 10px;
      z-index: 1000;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 14px;
    }

    #status {
      margin-top: 4px;
      font-size: 12px;
      color: #666;
    }
  </style>
</head>

<body>
  <div id="panel">
    ðŸ‘‰ Clique une rue : jâ€™affiche la rue EXACTE + toutes les lignes STM qui y passent.
    <div id="status"></div>
  </div>

  <div id="map"></div>

  <script>
    // ======================= 1. Initialisation carte =======================
    const map = L.map("map").setView([45.508, -73.587], 13);

    L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap"
    }).addTo(map);

    const statusDiv = document.getElementById("status");
    function setStatus(msg) {
      statusDiv.textContent = msg || "";
    }

    // ======================= 2. Gestion des segments dessinÃ©s =======================
    let activeStreetPolylines = [];

    function clearStreet() {
      activeStreetPolylines.forEach((p) => map.removeLayer(p));
      activeStreetPolylines = [];
    }

    function drawStreetSegments(segments) {
      clearStreet();

      segments.forEach((seg) => {
        if (!seg.geometry || seg.geometry.length < 2) return;

        const coords = seg.geometry.map((pt) => [pt.lat, pt.lon]);

        const poly = L.polyline(coords, {
          color: "#7b3fe4",        // violet mais cette fois SUR la rue
          weight: 6,
          opacity: 0.9
        }).addTo(map);

        activeStreetPolylines.push(poly);
      });
    }

    // ======================= 3. Overpass helpers =======================
    const OVERPASS_URL = "https://overpass-api.de/api/interpreter";

    async function overpassQuery(query) {
      try {
        const res = await fetch(OVERPASS_URL, {
          method: "POST",
          headers: { "Content-Type": "text/plain" },
          body: query
        });

        if (!res.ok) {
          throw new Error("HTTP " + res.status);
        }

        return await res.json();
      } catch (err) {
        console.error("Erreur Overpass :", err);
        throw err;
      }
    }

    // ---------- 3.a Trouver le nom EXACT de la rue cliquÃ©e ----------
    async function getStreetName(lat, lng) {
      const query = `
        [out:json][timeout:25];
        way(around:20, ${lat}, ${lng})["highway"]["name"];
        out tags;
      `;

      const json = await overpassQuery(query);

      if (!json.elements || json.elements.length === 0) {
        return null;
      }

      // On prend le premier nom trouvÃ©
      return json.elements[0].tags.name || null;
    }

    // ---------- 3.b RÃ©cupÃ©rer TOUS les segments de la rue autour du clic ----------
    async function getStreetSegments(streetName, lat, lng) {
      if (!streetName) return [];

      const query = `
        [out:json][timeout:25];
        way(around:250, ${lat}, ${lng})["highway"]["name"="${streetName}"];
        out geom;
      `;

      const json = await overpassQuery(query);
      return json.elements || [];
    }

    // ---------- 3.c Trouver toutes les lignes STM utilisant ces segments ----------
    async function getStmLinesForSegments(segments) {
      if (!segments.length) return [];

      // On construit une liste de rel(bw:ID) pour chaque segment
      const relSelectors = segments
        .map((seg) => `rel(bw:${seg.id})["route"="bus"]["network"~"STM"];`)
        .join("\n");

      const query = `
        [out:json][timeout:25];
        (
          ${relSelectors}
        );
        out tags;
      `;

      const json = await overpassQuery(query);
      if (!json.elements) return [];

      const refs = new Set();

      json.elements.forEach((rel) => {
        if (!rel.tags) return;

        // La plupart des lignes STM ont ref=24, 105, 138, etc.
        const ref = rel.tags.ref || rel.tags.name
