<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>D√©tours STM ‚Äì Rue + lignes + trac√© avanc√©</title>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    html,
    body {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    #map {
      height: 100%;
      width: 100%;
    }

    /* Panneau d‚Äôinstructions */
    .info-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      max-width: 95%;
      background: white;
      padding: 10px 14px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      font-size: 16px;
      line-height: 1.4;
    }

    .info-panel strong {
      font-weight: 600;
    }

    /* L√©gende des lignes STM */
    .stm-legend {
      background: white;
      padding: 8px 10px;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
      font-size: 13px;
      line-height: 1.4;
    }

    .stm-legend-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .stm-legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 2px;
    }

    .stm-legend-color {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      flex-shrink: 0;
    }

    /* Popups un peu plus lisibles */
    .leaflet-popup-content {
      margin: 8px 10px;
      font-size: 14px;
      line-height: 1.4;
    }

    .leaflet-popup-content b {
      font-weight: 600;
    }
  </style>
</head>

<body>
  <div class="info-panel">
    üëâ <strong>Clique une rue</strong> : j‚Äôaffiche la rue <strong>EXACTE</strong>
    + les <strong>lignes STM</strong> associ√©es + le <strong>trac√©</strong> (multi-lignes).
  </div>
  <div id="map"></div>

  <script>
    // ---------------------------
    //  Configuration & variables
    // ---------------------------

    const map = L.map("map").setView([45.5017, -73.5673], 15); // Centre Montr√©al

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution:
        '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a>',
    }).addTo(map);

    // Couches pour g√©rer les trac√©s
    const baseStreetLayer = L.layerGroup().addTo(map); // rue en gris
    const busLinesLayer = L.layerGroup().addTo(map); // lignes STM color√©es
    const busStopsLayer = L.layerGroup().addTo(map); // arr√™ts STM

    let currentPopup = null;

    // Couleurs associ√©es √† certaines lignes STM (fallback: bleu)
    const LINE_COLORS = {
      "24": "#0072ff",
      "105": "#00b050",
      "138": "#ff4b4b",
      "356": "#ff9900",
      // autres lignes possibles
      "66": "#9c27b0",
      "80": "#f44336",
      "129": "#3f51b5",
      "165": "#009688",
    };

    // L√©gende STM
    let legendContainer = null;
    const legendControl = L.control({ position: "bottomleft" });

    legendControl.onAdd = function () {
      legendContainer = L.DomUtil.create("div", "stm-legend");
      legendContainer.innerHTML =
        "<div class='stm-legend-title'>Lignes STM</div><div>Aucune donn√©e</div>";
      return legendContainer;
    };

    legendControl.addTo(map);

    function updateLegend(linesSet) {
      if (!legendContainer) return;
      const lines = Array.from(linesSet).sort((a, b) => {
        const na = parseInt(a, 10);
        const nb = parseInt(b, 10);
        if (!isNaN(na) && !isNaN(nb)) return na - nb;
        return a.localeCompare(b);
      });

      if (!lines.length) {
        legendContainer.innerHTML =
          "<div class='stm-legend-title'>Lignes STM</div><div>Aucune donn√©e</div>";
        return;
      }

      legendContainer.innerHTML =
        "<div class='stm-legend-title'>Lignes STM</div>";
      lines.forEach((line) => {
        const color = LINE_COLORS[line] || "#0066ff";
        const div = document.createElement("div");
        div.className = "stm-legend-item";
        div.innerHTML = `
          <span class="stm-legend-color" style="background:${color}"></span>
          <span>Ligne ${line}</span>
        `;
        legendContainer.appendChild(div);
      });
    }

    // ---------------------------
    //  Utilitaires
    // ---------------------------

    function normalizeStreetName(name) {
      if (!name) return null;
      return name
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    function escapeOverpassString(str) {
      return String(str).replace(/"/g, '\\"');
    }

    function showPopup(latlng, html) {
      if (currentPopup) {
        map.removeLayer(currentPopup);
      }
      currentPopup = L.popup().setLatLng(latlng).setContent(html).openOn(map);
    }

    // ---------------------------
    //  Requ√™tes Overpass
    // ---------------------------

    async function overpassQuery(query) {
      const res = await fetch("https://overpass-api.de/api/interpreter", {
        method: "POST",
        body: query,
      });
      if (!res.ok) throw new Error("Erreur Overpass");
      return res.json();
    }

    // 1) Trouver le nom exact de la rue √† partir du clic
    async function getExactStreetName(lat, lng) {
      const query = `
        [out:json][timeout:25];
        way(around:25,${lat},${lng})["highway"]["name"];
        out tags center;
      `;
      const json = await overpassQuery(query);
      if (!json.elements || !json.elements.length) return null;

      // On prend le nom le plus long (souvent le plus pr√©cis)
      json.elements.sort((a, b) => {
        const na = (a.tags && a.tags.name ? a.tags.name.length : 0);
        const nb = (b.tags && b.tags.name ? b.tags.name.length : 0);
        return nb - na;
      });

      return json.elements[0].tags.name;
    }

    // 2) R√©cup√©rer les segments de la rue autour du clic
    async function getStreetSegmentsAround(streetName, lat, lng) {
      const safeName = escapeOverpassString(streetName);
      const query = `
        [out:json][timeout:30];
        way(around:450,${lat},${lng})["highway"]["name"="${safeName}"];
        out geom;
      `;
      const json = await overpassQuery(query);
      return json.elements || [];
    }

    // 3) R√©cup√©rer les arr√™ts STM autour du clic + lignes
    async function getBusStopsAndLines(lat, lng) {
      const query = `
        [out:json][timeout:30];
        (
          node(around:150,${lat},${lng})["highway"="bus_stop"];
          node(around:150,${lat},${lng})["public_transport"="platform"]["bus"="yes"];
        );
        out tags center;
      `;
      const json = await overpassQuery(query);
      const stops = [];
      const linesSet = new Set();

      (json.elements || []).forEach((el) => {
        const tags = el.tags || {};
        const lat = el.lat || (el.center && el.center.lat);
        const lon = el.lon || (el.center && el.center.lon);
        if (lat == null || lon == null) return;

        const rawRefs =
          tags["ref:STM"] ||
          tags["ref"] ||
          tags["route_ref"] ||
          tags["bus_routes"] ||
          "";
        const lineMatches = String(rawRefs).match(/\d{1,3}/g) || [];

        lineMatches.forEach((ln) => linesSet.add(ln));

        stops.push({
          name: tags.name || "Arr√™t STM",
          lat,
          lon,
          lines: lineMatches,
        });
      });

      return { stops, linesSet };
    }

    // ---------------------------
    //  Dessin sur la carte
    // ---------------------------

    function drawBaseStreet(segments) {
      baseStreetLayer.clearLayers();
      segments.forEach((el) => {
        if (!el.geometry || !el.geometry.length) return;
        const latlngs = el.geometry.map((g) => [g.lat, g.lon]);
        L.polyline(latlngs, {
          color: "#555555",
          weight: 8,
          opacity: 0.6,
        }).addTo(baseStreetLayer);
      });
    }

    function drawBusLines(segments, linesSet) {
      busLinesLayer.clearLayers();

      const lines = Array.from(linesSet);
      if (!segments.length || !lines.length) return;

      lines.forEach((line, idx) => {
        const color = LINE_COLORS[line] || "#0066ff";

        // On applique un petit d√©calage en longitude pour s√©parer visuellement les lignes
        const offsetStep = 0.00006; // ~5‚Äì7 m
        const offset =
          (idx - (lines.length - 1) / 2) * offsetStep; // centr√© autour de la rue

        segments.forEach((el) => {
          if (!el.geometry || !el.geometry.length) return;
          const latlngs = el.geometry.map((g) => [g.lat, g.lon + offset]);
          L.polyline(latlngs, {
            color,
            weight: 4,
            opacity: 0.95,
          }).addTo(busLinesLayer);
        });
      });
    }

    function drawBusStops(stops) {
      busStopsLayer.clearLayers();
      stops.forEach((st) => {
        const hasLines = st.lines && st.lines.length;
        const color = hasLines ? "#000000" : "#888888";

        const marker = L.circleMarker([st.lat, st.lon], {
          radius: 4,
          color,
          weight: 1,
          fillColor: color,
          fillOpacity: 0.9,
        }).addTo(busStopsLayer);

        const linesText = hasLines ? st.lines.join(", ") : "Aucune donn√©e";
        marker.bindTooltip(
          `<b>${st.name}</b><br>Lignes : ${linesText}`,
          { direction: "top" }
        );
      });
    }

    // ---------------------------
    //  Gestion du clic sur la carte
    // ---------------------------

    map.on("click", async (e) => {
      const { lat, lng } = e.latlng;

      // Reset couches et popup
      baseStreetLayer.clearLayers();
      busLinesLayer.clearLayers();
      busStopsLayer.clearLayers();
      updateLegend(new Set());
      showPopup(e.latlng, "Recherche en cours‚Ä¶");

      try {
        // 1) Rue exacte
        const rawStreetName = await getExactStreetName(lat, lng);
        if (!rawStreetName) {
          showPopup(
            e.latlng,
            "<b>Rue :</b> inconnue<br><b>Lignes STM :</b> Aucune donn√©e"
          );
          return;
        }
        const normalized = normalizeStreetName(rawStreetName);

        // 2) Segments de la rue autour du clic
        const segments = await getStreetSegmentsAround(rawStreetName, lat, lng);

        if (!segments.length) {
          showPopup(
            e.latlng,
            `<b>Rue :</b> ${normalized}<br><b>Lignes STM :</b> Aucune donn√©e`
          );
          return;
        }

        drawBaseStreet(segments);

        // 3) Arr√™ts + lignes STM autour du clic
        const { stops, linesSet } = await getBusStopsAndLines(lat, lng);
        drawBusStops(stops);
        drawBusLines(segments, linesSet);
        updateLegend(linesSet);

        const lignesText = linesSet.size
          ? Array.from(linesSet)
              .sort((a, b) => {
                const na = parseInt(a, 10);
                const nb = parseInt(b, 10);
                if (!isNaN(na) && !isNaN(nb)) return na - nb;
                return a.localeCompare(b);
              })
              .join(", ")
          : "Aucune donn√©e";

        showPopup(
          e.latlng,
          `<b>Rue :</b> ${normalized}<br><b>Lignes STM :</b> ${lignesText}`
        );
      } catch (err) {
        console.error(err);
        showPopup(
          e.latlng,
          "<b>Erreur :</b> impossible de r√©cup√©rer les donn√©es (Overpass)."
        );
      }
    });
  </script>
</body>
</html>
